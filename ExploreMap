import cozmo
import time
from cozmo.util import degrees
import numpy as np
import matplotlib.pyplot as plt
import math

class M:
    def __init__(self):
        self.x = 0.0
        self.y = 0.0
        self.t = 0.0
        self.w = []
        self.p = [(0.0, 0.0)]
        self.fig, self.ax = plt.subplots(figsize=(10, 10))
        self.ax.set_xlim(-1000, 1000)
        self.ax.set_ylim(-1000, 1000)
        self.ax.set_aspect('equal')
        self.ax.grid(True, alpha=0.3)
        plt.ion()
        plt.show()
        
    def upd(self, l, r, d):
        wb = 45.0
        ld = l * d
        rd = r * d
        if abs(ld - rd) < 0.1:
            dist = (ld + rd) / 2
            self.x += dist * math.cos(self.t)
            self.y += dist * math.sin(self.t)
        else:
            rad = wb * (ld + rd) / (2 * (rd - ld))
            ang = (rd - ld) / wb
            self.x += rad * (math.sin(self.t + ang) - math.sin(self.t))
            self.y -= rad * (math.cos(self.t + ang) - math.cos(self.t))
            self.t += ang
        self.t = math.atan2(math.sin(self.t), math.cos(self.t))
        self.p.append((self.x, self.y))
    
    def turn(self, a):
        self.t += math.radians(a)
        self.t = math.atan2(math.sin(self.t), math.cos(self.t))
        self.p.append((self.x, self.y))
    
    def wall(self, d=100):
        wx = self.x + d * math.cos(self.t)
        wy = self.y + d * math.sin(self.t)
        wl = 200
        wa = self.t + math.pi / 2
        x1 = wx - (wl / 2) * math.cos(wa)
        y1 = wy - (wl / 2) * math.sin(wa)
        x2 = wx + (wl / 2) * math.cos(wa)
        y2 = wy + (wl / 2) * math.sin(wa)
        self.w.append((x1, y1, x2, y2))
    
    def draw(self):
        self.ax.clear()
        self.ax.set_xlim(min(-1000, self.x - 500), max(1000, self.x + 500))
        self.ax.set_ylim(min(-1000, self.y - 500), max(1000, self.y + 500))
        self.ax.set_aspect('equal')
        self.ax.grid(True, alpha=0.3)
        if len(self.p) > 1:
            px = [p[0] for p in self.p]
            py = [p[1] for p in self.p]
            self.ax.plot(px, py, 'b-', alpha=0.5, linewidth=1)
        for w in self.w:
            self.ax.plot([w[0], w[2]], [w[1], w[3]], 'r-', linewidth=3)
        self.ax.plot(self.x, self.y, 'go', markersize=10)
        ax = self.x + 80 * math.cos(self.t)
        ay = self.y + 80 * math.sin(self.t)
        self.ax.arrow(self.x, self.y, ax - self.x, ay - self.y, head_width=30, head_length=30, fc='green', ec='green')
        plt.draw()
        plt.pause(0.01)

def explore(robot: cozmo.robot.Robot):
    robot.camera.image_stream_enabled = True
    m = M()
    try:
        while True:
            i1 = robot.world.latest_image
            if i1 is None:
                time.sleep(0.1)
                continue
            g1 = np.array(i1.raw_image.convert('L'))
            s = 150
            dt = 0.4
            robot.drive_wheels(s, s)
            time.sleep(dt)
            m.upd(s, s, dt)
            i2 = robot.world.latest_image
            if i2 is None:
                continue
            g2 = np.array(i2.raw_image.convert('L'))
            diff = np.mean(np.abs(g1.astype(float) - g2.astype(float)))
            if diff < 5:
                robot.drive_wheels(0, 0)
                time.sleep(0.1)
                m.wall(80)
                robot.drive_wheels(-150, -150)
                time.sleep(0.4)
                m.upd(-150, -150, 0.4)
                robot.drive_wheels(0, 0)
                time.sleep(0.2)
                robot.turn_in_place(degrees(90)).wait_for_completed()
                m.turn(90)
                time.sleep(0.3)
            m.draw()
    except KeyboardInterrupt:
        robot.drive_wheels(0, 0)
        plt.ioff()
        plt.show()

cozmo.run_program(explore)

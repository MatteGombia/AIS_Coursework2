#!/usr/bin/env python3
from distributions import Gaussian, GaussianTable, Uniform, plotGaussian
from particlefilter import *
import numpy as np
import sys


from math import pi, sqrt, pow, exp, sin

# choose your own logfile here, generated by generateW7Log.py, if you like - longer
# logs with more movement will probably yield better and more interesting results.
from w7_robotLog import*
#from w7_robotLog2 import*

# TODO: Implement this function, which should return the probability of a given observation in a given particle state
def xyaSensorModel(state, observation):
    return 1/exp(sqrt((state.x()-observation.x())**2+(state.y()-observation.y())**2+(sin(state.angle()-observation.angle()))**2))

if len(sys.argv) == 2:
	logName = sys.argv[1]+".py"
else:
	logName = "particleFilterLog.py"

# TODO select number of particles
numParticles = 30

# TODO determine a valid prior for the tracking (initial pose known) and localisation (initial pose unknown)
# cases
locPrior = Uniform(
		np.array([0,0,0]),
		np.array([10,10,pi]))

# The main data structure: array for particles, each represented as Frame2D
currentParticles = sampleFromPrior(locPrior,numParticles)

#noise injected in re-sampling process to avoid multiple exact duplications of a particle
# TODO Choose sensible re-sampling variation
xyaResampleVar = np.diag([10,10,10*pi/180])
# note here: instead of creating new gaussian random numbers every time, which is /very/ expensive,
# 	precompute a large table of them an recycle. GaussianTable does that internally
xyaResampleNoise = GaussianTable(np.zeros([3]),xyaResampleVar, 10000)

# Motion error model
cozmoOdomNoiseX = 0.2
cozmoOdomNoiseY = 0.2
cozmoOdomNoiseTheta = 0.001
xyaNoiseVar = np.diag([cozmoOdomNoiseX,cozmoOdomNoiseY,cozmoOdomNoiseTheta])
xyaNoise = GaussianTable(np.zeros([3]),xyaNoiseVar,10000) 

numData = len(robotFrames)
particleWeights = np.zeros([numParticles])

t = 0
logFile = open(logName, 'w')
print("from frame2d import Frame2D", file=logFile)
print("robotFrames = [", file=logFile)

#lastSensorReading = None
sensorOffset = 0
for f in range(numData):
    ts = robotFrames[f][0]
    frame = robotFrames[f][1]
    v = motionFrames[f][1]
    sensorReading = sensorFrames[f][1]

    # prediction
    # TODO: update with actual motion model
    for p in range(0, numParticles):
        currentParticles[p] = resample(currentParticles[p],xyaNoise)

    # likelihood weighting
    # TODO: implement xyaSensorModel [P(sensorReading|currentParticles[l])]
    for l in range(0, numParticles):
        particleWeights[l] = xyaSensorModel(currentParticles[l],sensorReading)

    # importance sampling
    # TODO: experiment with resampling noise and algorithm to get most stable accurate localisation
    VIParticles = resampleLowVar(currentParticles, particleWeights, numParticles, xyaResampleNoise)
        
    # update
    # TODO: determine what the best estimate for pose is, which should be put in localFrame. The
    # assignment below is definitely wrong!
    localFrame = Frame2D.fromMat(sensorReading.mat)
    currentParticles = VIParticles

    # read values from gaussian and store
    xhat = localFrame.x()
    yhat = localFrame.y()
    ahat = localFrame.angle()
    x = frame.x()
    y = frame.y()
    a = frame.angle()
    print("   (%d, Frame2D.fromXYA(%f,%f,%f), Frame2D.fromXYA(%f,%f,%f))\n" % (ts,xhat,yhat,ahat,x,y,a), end="", file=logFile)
    t += 1

print("]", file=logFile)
logFile.close()





import cozmo
import math
import time
from statistics import mean

from cozmo.util import degrees, Angle
from cozmo.objects import CustomObject, CustomObjectMarkers, CustomObjectTypes

# ===== EDITABLE WALL POSITIONS =====
# Define the ACTUAL physical positions of your markers in millimeters
# These should match where you physically place the markers in the real world
# 
# IMPORTANT: If triangulation keeps failing, your wall positions might not match
# your actual setup. Try these approaches:
# 1. Measure the actual distance between your physical markers
# 2. Adjust these coordinates to match that distance
# 3. OR move your markers to match these coordinates
# 
# Example: If your markers are 500mm apart, use:
#   WALL_POSITIONS = {'wall1': (0, 500), 'wall2': (500, 500)}
#
WALL_POSITIONS = {
    'wall1': (0, 122),      # Wall 1 position (x, y) in mm
    'wall2': (122, 122)    # Wall 2 position (x, y) in mm
}

# Map marker types to wall positions
# Change these to match which physical markers you place at each position
MARKER_TO_WALL = {
    'CustomType01': 'wall1',  # First marker type goes to wall1 position
    'CustomType02': 'wall2'   # Second marker type goes to wall2 position
}
# ===================================

walls = []
marked_walls_seen = []
walls_angles = []
wall_assignments = {}  # Maps detected marker objects to their fixed positions


def create_cozmo_walls(robot: cozmo.robot.Robot):
    types = [CustomObjectTypes.CustomType01,
             CustomObjectTypes.CustomType02,
             CustomObjectTypes.CustomType03,
             CustomObjectTypes.CustomType04,
             CustomObjectTypes.CustomType05,
             CustomObjectTypes.CustomType06,
             CustomObjectTypes.CustomType07,
             CustomObjectTypes.CustomType08,
             CustomObjectTypes.CustomType09,
             CustomObjectTypes.CustomType10,
             CustomObjectTypes.CustomType11,
             CustomObjectTypes.CustomType12,
             CustomObjectTypes.CustomType13,
             CustomObjectTypes.CustomType14,
             CustomObjectTypes.CustomType15,
             CustomObjectTypes.CustomType16]
    
    markers = [CustomObjectMarkers.Circles2,
             CustomObjectMarkers.Diamonds2,
             CustomObjectMarkers.Hexagons2,
             CustomObjectMarkers.Triangles2,
             CustomObjectMarkers.Circles3,
             CustomObjectMarkers.Diamonds3,
             CustomObjectMarkers.Hexagons3,
             CustomObjectMarkers.Triangles3,
             CustomObjectMarkers.Circles4,
             CustomObjectMarkers.Diamonds4,
             CustomObjectMarkers.Hexagons4,
             CustomObjectMarkers.Triangles4,
             CustomObjectMarkers.Circles5,
             CustomObjectMarkers.Diamonds5,
             CustomObjectMarkers.Hexagons5,
             CustomObjectMarkers.Triangles5]
    
    cozmo_walls = []
    
    print("Creating custom walls (synchronous method)...")
    
    # Define the first 8 walls with 200mm width
    for i in range(0, 8):
        wall = robot.world.define_custom_wall(types[i], markers[i], 200, 60, 50, 50, True)
        cozmo_walls.append(wall)
        print(f"  Defined wall {i+1}: {types[i]} with marker {markers[i]}")
    
    # Define the next 8 walls with 300mm width
    for i in range(8, 16):
        wall = robot.world.define_custom_wall(types[i], markers[i], 300, 60, 50, 50, True)
        cozmo_walls.append(wall)
        print(f"  Defined wall {i+1}: {types[i]} with marker {markers[i]}")
    
    print(f"Total walls defined: {len(cozmo_walls)}")
    return cozmo_walls


def add_wall(wall_x, wall_y):
    walls.append((wall_x, wall_y))


def handle_object_observed(evt, **kw):
    global walls, marked_walls_seen, walls_angles, wall_assignments
    
    print(f"[DEBUG] Object observed: {type(evt.obj).__name__}")
    
    if isinstance(evt.obj, CustomObject):
        if evt.obj not in marked_walls_seen:
            # Get the full object type
            full_type = str(evt.obj.object_type)
            print(f"[DEBUG] Full object type: '{full_type}'")
            
            # Try different ways to extract the type name
            marker_type = full_type.split('.')[-1]  # Extract last part after dot
            print(f"[DEBUG] Extracted marker type: '{marker_type}'")
            print(f"[DEBUG] Available mappings: {list(MARKER_TO_WALL.keys())}")
            
            # Check if this marker type is in our mapping
            if marker_type in MARKER_TO_WALL:
                wall_key = MARKER_TO_WALL[marker_type]
                fixed_position = WALL_POSITIONS[wall_key]
                
                marked_walls_seen.append(evt.obj)
                wall_assignments[evt.obj] = (wall_key, fixed_position)
                
                print(f"*** WALL DETECTED: {marker_type} ***")
                print(f"    Assigned to: {wall_key}")
                print(f"    Fixed position: {fixed_position}")
                
                add_wall(fixed_position[0], fixed_position[1])
            else:
                print(f"[WARNING] Detected marker '{marker_type}' but it's not in our mapping")
                print(f"[WARNING] Add this to MARKER_TO_WALL if you want to use it")
                
                # Auto-assign to next available wall position
                if len(marked_walls_seen) < len(WALL_POSITIONS):
                    wall_keys = list(WALL_POSITIONS.keys())
                    wall_key = wall_keys[len(marked_walls_seen)]
                    fixed_position = WALL_POSITIONS[wall_key]
                    
                    marked_walls_seen.append(evt.obj)
                    wall_assignments[evt.obj] = (wall_key, fixed_position)
                    
                    print(f"[AUTO-ASSIGN] Assigning {marker_type} to {wall_key} at {fixed_position}")
                    add_wall(fixed_position[0], fixed_position[1])


def normalise_angle(angle):
    while angle > math.pi:
        angle -= 2 * math.pi
    while angle < -math.pi:
        angle += 2 * math.pi
    return angle


def triangulate_from_two_markers(c1, c2, d1, d2):
    x1, y1 = c1
    x2, y2 = c2

    dx = x2 - x1
    dy = y2 - y1
    d = math.hypot(dx, dy)

    if d == 0:
        raise ValueError("Marker positions cannot be identical.")
    if d > d1 + d2:
        raise ValueError("No intersection: circles too far apart.")
    if d < abs(d1 - d2):
        raise ValueError("No intersection: one circle inside another.")

    a = (d1**2 - d2**2 + d**2) / (2 * d)
    h = math.sqrt(abs(d1**2 - a**2))

    x3 = x1 + a * dx / d
    y3 = y1 + a * dy / d

    rx1 = x3 + h * (dy / d)
    ry1 = y3 - h * (dx / d)

    rx2 = x3 - h * (dy / d)
    ry2 = y3 + h * (dx / d)

    return (rx1, ry1), (rx2, ry2)


def choose_correct_position(c1, c2, posA, posB, bearing1, bearing2):
    def bearing_error(robot_pos):
        xr, yr = robot_pos
        pred_b1 = math.atan2(c1[1] - yr, c1[0] - xr)
        pred_b2 = math.atan2(c2[1] - yr, c2[0] - xr)

        err1 = normalise_angle(pred_b1 - bearing1)
        err2 = normalise_angle(pred_b2 - bearing2)
        return abs(err1) + abs(err2)

    errA = bearing_error(posA)
    errB = bearing_error(posB)

    return posA if errA < errB else posB


def triangulate_with_fallback(c1, c2, d1, d2, b1, b2):
    """
    Try triangulation with various fallback strategies if direct triangulation fails.
    """
    x1, y1 = c1
    x2, y2 = c2
    wall_dist = math.hypot(x2 - x1, y2 - y1)
    
    print(f"\n[TRIANGULATION] Attempting triangulation...")
    print(f"  Wall separation: {wall_dist:.1f}mm")
    print(f"  Measured distances: d1={d1:.1f}mm, d2={d2:.1f}mm")
    print(f"  Sum of distances: {d1 + d2:.1f}mm")
    print(f"  Difference of distances: {abs(d1 - d2):.1f}mm")
    
    # Strategy 1: Try direct triangulation
    try:
        posA, posB = triangulate_from_two_markers(c1, c2, d1, d2)
        xr, yr = choose_correct_position(c1, c2, posA, posB, b1, b2)
        heading = (b1 + b2) / 2.0
        print(f"[SUCCESS] Direct triangulation worked!")
        return xr, yr, heading, "direct"
    except ValueError as e:
        print(f"[FALLBACK] Direct triangulation failed: {e}")
    
    # Strategy 2: Scale distances proportionally to make them valid
    if d1 + d2 < wall_dist:
        # Circles too far apart - scale up distances
        scale = (wall_dist * 1.1) / (d1 + d2)  # 10% overlap
        d1_scaled = d1 * scale
        d2_scaled = d2 * scale
        print(f"[FALLBACK] Strategy 2: Scaling distances up by {scale:.2f}x")
        print(f"  New distances: d1={d1_scaled:.1f}mm, d2={d2_scaled:.1f}mm")
        
        try:
            posA, posB = triangulate_from_two_markers(c1, c2, d1_scaled, d2_scaled)
            xr, yr = choose_correct_position(c1, c2, posA, posB, b1, b2)
            heading = (b1 + b2) / 2.0
            print(f"[SUCCESS] Scaled triangulation worked!")
            return xr, yr, heading, "scaled_up"
        except ValueError:
            print(f"[FALLBACK] Strategy 2 failed")
    
    elif abs(d1 - d2) > wall_dist:
        # One circle inside another - scale down the difference
        larger = max(d1, d2)
        smaller = min(d1, d2)
        new_larger = wall_dist * 0.9 + smaller
        scale = new_larger / larger
        d1_scaled = d1 * scale if d1 > d2 else d1
        d2_scaled = d2 * scale if d2 > d1 else d2
        print(f"[FALLBACK] Strategy 2: Reducing distance difference")
        print(f"  New distances: d1={d1_scaled:.1f}mm, d2={d2_scaled:.1f}mm")
        
        try:
            posA, posB = triangulate_from_two_markers(c1, c2, d1_scaled, d2_scaled)
            xr, yr = choose_correct_position(c1, c2, posA, posB, b1, b2)
            heading = (b1 + b2) / 2.0
            print(f"[SUCCESS] Adjusted triangulation worked!")
            return xr, yr, heading, "adjusted"
        except ValueError:
            print(f"[FALLBACK] Strategy 2 failed")
    
    # Strategy 3: Use bearing-based estimation
    print(f"[FALLBACK] Strategy 3: Using bearing-based position estimation")
    
    # Calculate approximate position using bearings and distances
    # Use the bearings to estimate robot position
    heading = (b1 + b2) / 2.0
    
    # Calculate position from each wall using distance and bearing
    x1_est = c1[0] - d1 * math.cos(b1)
    y1_est = c1[1] - d1 * math.sin(b1)
    
    x2_est = c2[0] - d2 * math.cos(b2)
    y2_est = c2[1] - d2 * math.sin(b2)
    
    # Average the two estimates
    xr = (x1_est + x2_est) / 2
    yr = (y1_est + y2_est) / 2
    
    print(f"[SUCCESS] Bearing-based estimation complete")
    print(f"  Position from wall1: ({x1_est:.1f}, {y1_est:.1f})")
    print(f"  Position from wall2: ({x2_est:.1f}, {y2_est:.1f})")
    print(f"  Averaged position: ({xr:.1f}, {yr:.1f})")
    
    return xr, yr, heading, "bearing_based"


def localise_robot(c1, c2, d1, d2, b1, b2):
    """Wrapper for backwards compatibility"""
    xr, yr, heading, method = triangulate_with_fallback(c1, c2, d1, d2, b1, b2)
    return xr, yr, heading


def get_marker_measurements(robot, marker_obj):
    dx = marker_obj.pose.position.x - robot.pose.position.x
    dy = marker_obj.pose.position.y - robot.pose.position.y

    dist = math.hypot(dx, dy)
    global_bearing = math.atan2(dy, dx)
    robot_heading = robot.pose.rotation.angle_z.radians

    rel_bearing = normalise_angle(global_bearing - robot_heading)
    return dist, rel_bearing


def average_measurements(robot, marker_obj, n=5):
    dists = []
    bears = []
    for _ in range(n):
        d, b = get_marker_measurements(robot, marker_obj)
        dists.append(d)
        bears.append(b)
        time.sleep(0.05)
    avg_d = mean(dists)
    avg_b = normalise_angle(mean(bears))
    return avg_d, avg_b


def scan_for_walls(robot: cozmo.robot.Robot, num_needed=2):
    global marked_walls_seen, walls, walls_angles, wall_assignments
    
    marked_walls_seen.clear()
    walls.clear()
    walls_angles.clear()
    wall_assignments.clear()
    
    steps = 18
    step_angle = 20
    
    print("\n" + "="*70)
    print("SCANNING FOR WALLS")
    print("="*70)
    print(f"Looking for {num_needed} wall markers...")
    print(f"Fixed wall positions: {WALL_POSITIONS}")
    print("Performing 360° scan...\n")
    
    for step in range(steps):
        if len(marked_walls_seen) >= num_needed:
            print(f"\n✓ Found {len(marked_walls_seen)} walls - stopping scan early")
            break
        
        print(f"Step {step+1}/{steps} - Walls found: {len(marked_walls_seen)}")
        
        if step < steps - 1:
            robot.turn_in_place(degrees(step_angle)).wait_for_completed()
            time.sleep(0.3)
    
    print("\n" + "="*70)
    print(f"SCAN COMPLETE - Found {len(marked_walls_seen)} walls")
    print("="*70 + "\n")
    
    return len(marked_walls_seen) >= num_needed


def main(robot: cozmo.robot.Robot):
    print("\n" + "="*70)
    print("COZMO SATELLITE-STYLE TRIANGULATION LOCALIZATION")
    print("Using FIXED wall positions for true triangulation")
    print("="*70)
    print(f"\nFixed Wall Positions:")
    for wall_key, pos in WALL_POSITIONS.items():
        print(f"  {wall_key}: ({pos[0]}, {pos[1]}) mm")
    print("\nMarker Mapping:")
    for marker_type, wall_key in MARKER_TO_WALL.items():
        pos = WALL_POSITIONS[wall_key]
        print(f"  {marker_type} -> {wall_key} at ({pos[0]}, {pos[1]})")
    print("="*70 + "\n")
    
    robot.camera.image_stream_enabled = True
    print("✓ Camera enabled")
    
    create_cozmo_walls(robot)
    
    robot.add_event_handler(cozmo.objects.EvtObjectObserved, handle_object_observed)
    print("✓ Event handler registered")
    
    print("✓ Waiting for initialisation...")
    time.sleep(1)
    
    robot.set_head_angle(Angle(0)).wait_for_completed()
    print("✓ Head angle set")
    
    time.sleep(1)
    
    success = scan_for_walls(robot, num_needed=2)
    
    if not success or len(marked_walls_seen) < 2:
        print("\n" + "="*70)
        print("ERROR: Could not find 2 walls")
        print("="*70)
        print(f"Walls found: {len(marked_walls_seen)}")
        if len(marked_walls_seen) > 0:
            print("Detected walls:")
            for i, wall in enumerate(marked_walls_seen):
                wall_key, pos = wall_assignments[wall]
                print(f"  {i+1}. {wall_key} at fixed position {pos}")
        return
    
    print("\n" + "="*70)
    print("PERFORMING TRIANGULATION")
    print("="*70)
    
    marker1 = marked_walls_seen[0]
    marker2 = marked_walls_seen[1]
    c1 = walls[0]
    c2 = walls[1]
    
    wall1_key, wall1_pos = wall_assignments[marker1]
    wall2_key, wall2_pos = wall_assignments[marker2]
    
    print(f"\nUsing walls:")
    print(f"  {wall1_key}: Fixed at ({c1[0]:.1f}, {c1[1]:.1f})")
    print(f"  {wall2_key}: Fixed at ({c2[0]:.1f}, {c2[1]:.1f})")
    
    print("\nMeasuring distances and bearings...")
    d1, b1 = average_measurements(robot, marker1, n=5)
    d2, b2 = average_measurements(robot, marker2, n=5)
    
    print(f"  {wall1_key}: dist={d1:.1f}mm, bearing={math.degrees(b1):.1f}°")
    print(f"  {wall2_key}: dist={d2:.1f}mm, bearing={math.degrees(b2):.1f}°")
    
    xr, yr, heading, method = triangulate_with_fallback(c1, c2, d1, d2, b1, b2)
    
    print("\n" + "="*70)
    print("TRIANGULATION RESULTS")
    print("="*70)
    print(f"Method used: {method}")
    print(f"Calculated Robot Position: ({xr:.1f}, {yr:.1f}) mm")
    print(f"Calculated Robot Heading: {heading:.3f} rad ({math.degrees(heading):.1f}°)")
    print("="*70)
    
    print("\n" + "="*70)
    print("COZMO INTERNAL POSE (for comparison)")
    print("="*70)
    print(f"Internal Position: ({robot.pose.position.x:.1f}, {robot.pose.position.y:.1f}) mm")
    print(f"Internal Heading: {robot.pose.rotation.angle_z.radians:.3f} rad ({robot.pose.rotation.angle_z.degrees:.1f}°)")
    print("="*70)
    
    # Calculate error
    error_x = abs(xr - robot.pose.position.x)
    error_y = abs(yr - robot.pose.position.y)
    error_dist = math.hypot(error_x, error_y)
    error_heading = abs(normalise_angle(heading - robot.pose.rotation.angle_z.radians))
    
    print("\n" + "="*70)
    print("LOCALIZATION ERROR")
    print("="*70)
    print(f"Position error: {error_dist:.1f} mm")
    print(f"  X error: {error_x:.1f} mm")
    print(f"  Y error: {error_y:.1f} mm")
    print(f"Heading error: {math.degrees(error_heading):.1f}°")
    print("="*70)
    
    # Provide recommendations based on method used
    if method != "direct":
        print("\n" + "="*70)
        print("⚠️  RECOMMENDATIONS")
        print("="*70)
        print(f"Triangulation used fallback method: '{method}'")
        print("\nFor better accuracy, consider:")
        print(f"1. The actual distance between your markers")
        print(f"   Current setting: {math.hypot(c2[0]-c1[0], c2[1]-c1[1]):.1f}mm")
        print(f"   Measured distances suggest: ~{d1+d2:.1f}mm total reach")
        
        # Calculate suggested wall positions based on measurements
        actual_separation = min(d1 + d2, abs(d1 - d2) * 1.5)
        suggested_pos1 = (0, int(actual_separation))
        suggested_pos2 = (int(actual_separation), int(actual_separation))
        
        print(f"\n2. Try adjusting WALL_POSITIONS to:")
        print(f"   'wall1': {suggested_pos1}")
        print(f"   'wall2': {suggested_pos2}")
        print("\n3. OR move your physical markers to better match")
        print("   the current WALL_POSITIONS settings")
        print("="*70 + "\n")
    else:
        print("\n✓ Direct triangulation succeeded - wall positions are accurate!\n")


if __name__ == "__main__":
    cozmo.run_program(main)
